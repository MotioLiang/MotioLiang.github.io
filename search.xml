<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GIT新建分支并推送到远程仓库]]></title>
    <url>%2F2019%2F02%2F24%2Fgit%2F</url>
    <content type="text"><![CDATA[12345678910111213git init //初始化版本库git remote add origin 你的远程库地址 // 把本地库与远程库关联git checkout master //切换到基础分支，如主干git checkout -b panda //创建并切换到新分支[panda]git add . // 添加文件到版本库（只是添加到缓存区），.代表添加文件夹下所有文件 git commit -m &quot;first commit&quot; // 把添加的文件提交到版本库，并填写提交备注git push origin panda / 推送到远程仓库]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin15.9安装nginx]]></title>
    <url>%2F2019%2F02%2F03%2Fnginx%2F</url>
    <content type="text"><![CDATA[一、使用wget命令下载1wget -c https://nginx.org/download/nginx-1.15.0.tar.gz 二、配置1./configure 三、编译安装1.安装12makemake install 2.查看安装路径1whereis nginx 四、启动停止nginx12345cd /user/local/nginx/sbin/./nginx./nginx -s stop./nginx -s quit./nginx -s reload ./nginx -s quit:此方式停止步骤是待nginx进程处理任务完毕进行停止。./nginx -s stop:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。 五、查询nginx进程1ps aux|grep nginx 六、重启nginx 1.先停止再启动（推荐）：对 nginx 进行重启相当于先停止再启动，即先执行停止命令再执行启动命令。如下：12./nginx -s quit./nginx 2.重新加载配置文件：当 ngin x的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，使用-s reload不用先停止 nginx 再启动 nginx 即可将配置信息在 nginx 中生效，如下：1./nginx -s reload 七、开机自启动 即在rc.local增加启动代码就可以了。1vi /etc/rc.local 增加一行 /usr/local/nginx/sbin/nginx设置执行权限：1chmod 755 rc.local]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql对自增主键ID进行重新排序]]></title>
    <url>%2F2018%2F12%2F25%2Fmysql-id%2F</url>
    <content type="text"><![CDATA[一、不清空数据原理：删除原有的自增ID，重新建立新的自增ID。1.删除原有主键:1ALTER TABLE `table_name` DROP `id`; 2.添加新主键字段并设置主键:1ALTER TABLE `table_name` ADD &apos;id&apos; mediumint(6) PRIMARY KEY NOT NULL AUTO_INCREMENT FIRST; 二、如果曾经的数据都不需要的话，可以直接清空所有数据，并将自增字段恢复从1开始计数1truncate table 表名]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript Standard Style VScode 配置]]></title>
    <url>%2F2018%2F11%2F10%2Fvscode%2F</url>
    <content type="text"><![CDATA[Javascript Standard Style VScode 配置123456789101112131415161718&quot;editor.tabSize&quot;: 2,// 保存自动化&quot;editor.formatOnSave&quot;: true,// 保存时自动fix&quot;eslint.autoFixOnSave&quot;: true,// 添加 vue 支持&quot;eslint.validate&quot;: [ &quot;javascript&quot;, &quot;javascriptreact&quot;, &#123; &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true &#125;],// 使用插件格式化 html&quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,// 屏蔽vetur的js格式化&quot;vetur.format.defaultFormatter.js&quot;: &quot;none&quot;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web worker简易入门]]></title>
    <url>%2F2018%2F09%2F25%2Fweb-worker-learning%2F</url>
    <content type="text"><![CDATA[js是单线程的语言，由于此特性，我们在处理并发时需要用到一些技巧，如setTimeout()，setInterval()，调用XMLHttpRequest等。但这里的并发只是非阻塞（参照John Resig的文章How JavaScript Timers Work），真正的多线程编程则需要HTML5的web worker。 【worker的使用】web worker的使用非常简单，线程之间通讯的api与html5 postmessage或node.js里面的socket.io方法类似。 通讯： 发送方：postMessage(data) 接收方：onmessage(event) 终止web worker: 子线程: self.close() 父线程: worker.terminate() 按照目前w3c规范，web worker分为两种：专用worker(Dedicated Worker)和共享worker(Shared Worker)。 【专用worker】实例化一个web worker对象，异步加载子线程文件worker.js，其中的代码将执行。 var worker = new Worker(&quot;worker.js&quot;); 给worker增加侦听 worker.onmessage = function (event) { alert(event.data); }; 在worker.js里，发送消息给父线程 postMessage(&apos;hello，imweb&apos;); 在父线程页面就能看到发送过来的信息了。 同时，在web worker标准中，是支持对象参数的，也就是说我们能够传递json数据。再看一个稍微复杂点的例子，父线程： var worker = new Worker(&quot;worker.js&quot;); worker.onmessage = function (event) { document.getElementById(&quot;result&quot;).innerHTML=event.data; }; function start(){ worker.postMessage({&apos;cmd&apos;: &apos;start&apos;, &apos;msg&apos;: &apos;start&apos;}); } function pause(){ worker.postMessage({&apos;cmd&apos;: &apos;pause&apos;, &apos;msg&apos;: &apos;pause&apos;}); } function stop(){ worker.postMessage({&apos;cmd&apos;: &apos;stop&apos;, &apos;msg&apos;: &apos;stop&apos;}); } function msg(){ worker.postMessage({&apos;msg&apos;: &apos;hello imweb&apos;}); } worker.js： self.onmessage = function (e) { var data = e.data; switch (data.cmd) { case &apos;start&apos;: taskStart(); //大量数据处理 postMessage(&apos;WORKER DO: &apos; + data.msg); break; case &apos;pause&apos;: taskPause(); postMessage(&apos;WORKER DO: &apos; + data.msg); break; case &apos;stop&apos;: postMessage(&apos;WORKER DO: &apos; + data.msg); self.close(); //终止web worker break; default: postMessage(&apos;MESSAGE: &apos; + data.msg); }; }; 从上面的例子可以看到，一是利用对象参数，进程之间能够较灵活的实现控制；二是当woker执行taskStart()处理大量数据时，只在子进程处理，不会给主页面带来阻塞，通常，处理大量数据会消极影响程序的响应能力，而web worker通过这样的方式，能提供一个更流畅更实时的UI。 【共享worker】共享worker允许线程在同源中的多个页面间进行共享，例如：同源中所有页面或脚本可以与同一个共享线程通信。它的实例化与事件侦听的写法与专用worker略有不同,主页面： var worker = new SharedWorker(&apos;shared-worker.js&apos;); worker.port.onmessage = function(e) { msg = &apos;Someone just said &quot;&apos; + e.data.message + &apos;&quot;. That is message number &apos; + e.data.counter; console.log(msg); }; worker.port.postMessage(&apos;hello shared worker!&apos;); shared-worker.js: var counter = 0; var connections = []; onconnect = function(eConn) { var port = eConn.ports[0]; // 此连接的特有port //当有消息的时候通知所有的连接 port.onmessage = function(eMsg) { counter++; for (var i=0; i &lt; connections.length; i++) { connections[i].postMessage({ message: eMsg.data, counter: counter }); } } port.start(); connections.push(port); 用两个窗口打开这个页面，第一个显示：Someone just said “Hello shared worker!” This is message number 1，第二个也收到一样的信息，但是后面是message number 2。 【安全性和错误检查】出于安全性的考虑，web worker必须遵守同源策略。同时，它的全局对象是worker对象本身，this和self引用的都是worker对象。只能访问： navigator 对象（仅限appName, appVersion, platform, userAgent） location 对象（只读） XMLHttpRequest setTimeout(), setInterval(), clearTimeout()和clearInterval()方法 不能访问： DOM(不是线程安全的) window 对象 document 对象 parent 对象 worker内部出现错误时，可以用worker.onerror侦听到，error的事件有三个属性： filename: 发生错误的文件名 lineno: 代码行号 message: 完整的错误信息 如： worker.onerror = function(e) { console.log(e.filename+&quot;ERROR on line&quot;+e.lineno+&quot;,msg:&quot;+e.message); } 【web worker的其他尝试】对于比较消耗时间的操作，我们可看到web worker能够发挥它的作用。比如：大量数据排序，精确到像素的canvas计算等。而我们又知道，jsonp加载数据时，动态创建script标签，加载和执行这些过程都是阻塞式的，而web worker正好可以异步加载，这会是更快的方式吗？带着这个疑问我做了下面的试验，分别用jsonp和worker的方式去加载文件，计算数据返回时延： function tryJsonp(){ var d = (new Date()).valueOf(); var jsonp=document.createElement(&quot;script&quot;); jsonp.type=&quot;text/javascript&quot;; jsonp.src=&quot;worker.js?_=&quot;+d; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(jsonp); jsonp.onload = jsonp.onreadystatechange = function(){ if(!this.readyState||this.readyState==&apos;loaded&apos;||this.readyState==&apos;complete&apos;){ console.log(&apos;jsonp: &apos;+ ((new Date()).valueOf() - d)); } } } function tryWorker(){ var d = (new Date()).valueOf(); var worker = new Worker(&quot;worker.js&quot;); worker.postMessage({&apos;cmd&apos;: &apos;start&apos;, &apos;msg&apos;: &apos;start&apos;}); worker.onmessage = function (event) { console.log(&apos;web worker: &apos;+ ((new Date()).valueOf() - d)); }; } 第一次加载是一份1k大小的文件，每个方法重复5次，返回结果为:第二次加载1800k大小的文件，返回结果为：可以看到对于较小的数据，jsonp还是比web worker要快，这可能是实例化worker对象时带来的影响；而数据偏大时，web worker的加载将会更优，而且它可以异步加载。 THE END. 本文转自Litten]]></content>
      <tags>
        <tag>web</tag>
        <tag>html5</tag>
      </tags>
  </entry>
</search>
