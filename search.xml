<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[函数防抖和节流]]></title>
    <url>%2F2019%2F02%2F27%2Ffd%2F</url>
    <content type="text"><![CDATA[在前端开发中会遇到一些频繁的事件触发，比如： window 的 resize、scroll mousedown、mousemove keyup、keydown … 通常这种情况下我们怎么去解决的呢？一般来讲，防抖和节流 是比较好的解决方案。让我们先来看看在事件持续触发的过程中频繁执行函数是怎样的一种情况。 我们写个 index.html 文件： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge, chrome=1&quot;&gt; &lt;title&gt;debounce&lt;/title&gt; &lt;style&gt; #container&#123; width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #444; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;script&gt; let num = 1; let content = document.getElementById(&apos;container&apos;); function count() &#123; content.innerHTML = num++; &#125;; content.onmousemove = count; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在上述代码中，div 元素绑定了 mousemove 事件，当鼠标在 div（灰色）区域中移动的时候会持续地去触发该事件导致频繁执行函数。效果如下 可以看到，在没有通过其它操作的情况下，函数被频繁地执行导致页面上数据变化特别快。 为了解决这个问题，一般有两种解决方案： debounce 防抖 throttle 节流 防抖（debounce） 所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 防抖函数分为非立即执行版和立即执行版。 非立即执行版： 12345678910111213function debounce(func, wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; func.apply(context, args) &#125;, wait); &#125;&#125; 非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 我们依旧使用上述绑定 mousemove 事件的例子，通过上面的防抖函数，我们可以这么使用 1content.onmousemove = debounce(count,1000); 在触发事件后函数 1 秒后才执行，而如果我在触发事件后的 1 秒内又触发了事件，则会重新计算函数执行时间。效果如下： 上述防抖函数的代码还需要注意的是 this 和 参数的传递 12let context = this;let args = arguments; 防抖函数的代码使用这两行代码来获取 this 和 参数，是为了让 debounce 函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数。 立即执行版： 12345678910111213141516function debounce(func,wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); let callNow = !timeout; timeout = setTimeout(() =&gt; &#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125;&#125; 立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。 在开发过程中，我们需要根据不同的场景来决定我们需要使用哪一个版本的防抖函数，一般来讲上述的防抖函数都能满足大部分的场景需求。但我们也可以将非立即执行版和立即执行版的防抖函数结合起来，实现最终的双剑合璧版的防抖函数。 双剑合璧版： 12345678910111213141516171819202122232425262728/** * @desc 函数防抖 * @param func 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表非立即执行 */function debounce(func,wait,immediate) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; var callNow = !timeout; timeout = setTimeout(() =&gt; &#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125; 节流（throttle） 所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。 对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。 时间戳版： 123456789101112function throttle(func, wait) &#123; let previous = 0; return function() &#123; let now = Date.now(); let context = this; let args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125; 使用方式如下 1content.onmousemove = throttle(count,1000); 效果演示如下： 可以看到，在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。 定时器版： 1234567891011121314function throttle(func, wait) &#123; let timeout; return function() &#123; let context = this; let args = arguments; if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 使用方式同上，效果如下 可以看到，在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。 我们应该可以很容易的发现，其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。 1234567891011121314151617181920212223242526272829303132/** * @desc 函数节流 * @param func 函数 * @param wait 延迟执行毫秒数 * @param type 1 表时间戳版，2 表定时器版 */function throttle(func, wait ,type) &#123; if(type===1)&#123; let previous = 0; &#125;else if(type===2)&#123; let timeout; &#125; return function() &#123; let context = this; let args = arguments; if(type===1)&#123; let now = Date.now(); if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;else if(type===2)&#123; if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT新建分支并推送到远程仓库]]></title>
    <url>%2F2019%2F02%2F24%2Fgit%2F</url>
    <content type="text"><![CDATA[12345678910111213git init //初始化版本库git remote add origin 你的远程库地址 // 把本地库与远程库关联git checkout master //切换到基础分支，如主干git checkout -b panda //创建并切换到新分支[panda]git add . // 添加文件到版本库（只是添加到缓存区），.代表添加文件夹下所有文件 git commit -m &quot;first commit&quot; // 把添加的文件提交到版本库，并填写提交备注git push origin panda / 推送到远程仓库[panda]]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin15.9安装nginx]]></title>
    <url>%2F2019%2F02%2F03%2Fnginx%2F</url>
    <content type="text"><![CDATA[一、使用wget命令下载1wget -c https://nginx.org/download/nginx-1.15.0.tar.gz 二、配置1./configure 三、编译安装1.安装12makemake install 2.查看安装路径1whereis nginx 四、启动停止nginx12345cd /user/local/nginx/sbin/./nginx./nginx -s stop./nginx -s quit./nginx -s reload ./nginx -s quit:此方式停止步骤是待nginx进程处理任务完毕进行停止。./nginx -s stop:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。 五、查询nginx进程1ps aux|grep nginx 六、重启nginx 1.先停止再启动（推荐）：对 nginx 进行重启相当于先停止再启动，即先执行停止命令再执行启动命令。如下：12./nginx -s quit./nginx 2.重新加载配置文件：当 ngin x的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，使用-s reload不用先停止 nginx 再启动 nginx 即可将配置信息在 nginx 中生效，如下：1./nginx -s reload 七、开机自启动 即在rc.local增加启动代码就可以了。1vi /etc/rc.local 增加一行 /usr/local/nginx/sbin/nginx设置执行权限：1chmod 755 rc.local]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql对自增主键ID进行重新排序]]></title>
    <url>%2F2018%2F12%2F25%2Fmysql-id%2F</url>
    <content type="text"><![CDATA[一、不清空数据原理：删除原有的自增ID，重新建立新的自增ID。1.删除原有主键:1ALTER TABLE `table_name` DROP `id`; 2.添加新主键字段并设置主键:1ALTER TABLE `table_name` ADD &apos;id&apos; mediumint(6) PRIMARY KEY NOT NULL AUTO_INCREMENT FIRST; 二、如果曾经的数据都不需要的话，可以直接清空所有数据，并将自增字段恢复从1开始计数1truncate table 表名]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript Standard Style VScode 配置]]></title>
    <url>%2F2018%2F11%2F10%2Fvscode%2F</url>
    <content type="text"><![CDATA[Javascript Standard Style VScode 配置123456789101112131415161718&quot;editor.tabSize&quot;: 2,// 保存自动化&quot;editor.formatOnSave&quot;: true,// 保存时自动fix&quot;eslint.autoFixOnSave&quot;: true,// 添加 vue 支持&quot;eslint.validate&quot;: [ &quot;javascript&quot;, &quot;javascriptreact&quot;, &#123; &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true &#125;],// 使用插件格式化 html&quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,// 屏蔽vetur的js格式化&quot;vetur.format.defaultFormatter.js&quot;: &quot;none&quot;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web worker简易入门]]></title>
    <url>%2F2018%2F09%2F25%2Fweb-worker-learning%2F</url>
    <content type="text"><![CDATA[js是单线程的语言，由于此特性，我们在处理并发时需要用到一些技巧，如setTimeout()，setInterval()，调用XMLHttpRequest等。但这里的并发只是非阻塞（参照John Resig的文章How JavaScript Timers Work），真正的多线程编程则需要HTML5的web worker。 【worker的使用】web worker的使用非常简单，线程之间通讯的api与html5 postmessage或node.js里面的socket.io方法类似。 通讯： 发送方：postMessage(data) 接收方：onmessage(event) 终止web worker: 子线程: self.close() 父线程: worker.terminate() 按照目前w3c规范，web worker分为两种：专用worker(Dedicated Worker)和共享worker(Shared Worker)。 【专用worker】实例化一个web worker对象，异步加载子线程文件worker.js，其中的代码将执行。 var worker = new Worker(&quot;worker.js&quot;); 给worker增加侦听 worker.onmessage = function (event) { alert(event.data); }; 在worker.js里，发送消息给父线程 postMessage(&apos;hello，imweb&apos;); 在父线程页面就能看到发送过来的信息了。 同时，在web worker标准中，是支持对象参数的，也就是说我们能够传递json数据。再看一个稍微复杂点的例子，父线程： var worker = new Worker(&quot;worker.js&quot;); worker.onmessage = function (event) { document.getElementById(&quot;result&quot;).innerHTML=event.data; }; function start(){ worker.postMessage({&apos;cmd&apos;: &apos;start&apos;, &apos;msg&apos;: &apos;start&apos;}); } function pause(){ worker.postMessage({&apos;cmd&apos;: &apos;pause&apos;, &apos;msg&apos;: &apos;pause&apos;}); } function stop(){ worker.postMessage({&apos;cmd&apos;: &apos;stop&apos;, &apos;msg&apos;: &apos;stop&apos;}); } function msg(){ worker.postMessage({&apos;msg&apos;: &apos;hello imweb&apos;}); } worker.js： self.onmessage = function (e) { var data = e.data; switch (data.cmd) { case &apos;start&apos;: taskStart(); //大量数据处理 postMessage(&apos;WORKER DO: &apos; + data.msg); break; case &apos;pause&apos;: taskPause(); postMessage(&apos;WORKER DO: &apos; + data.msg); break; case &apos;stop&apos;: postMessage(&apos;WORKER DO: &apos; + data.msg); self.close(); //终止web worker break; default: postMessage(&apos;MESSAGE: &apos; + data.msg); }; }; 从上面的例子可以看到，一是利用对象参数，进程之间能够较灵活的实现控制；二是当woker执行taskStart()处理大量数据时，只在子进程处理，不会给主页面带来阻塞，通常，处理大量数据会消极影响程序的响应能力，而web worker通过这样的方式，能提供一个更流畅更实时的UI。 【共享worker】共享worker允许线程在同源中的多个页面间进行共享，例如：同源中所有页面或脚本可以与同一个共享线程通信。它的实例化与事件侦听的写法与专用worker略有不同,主页面： var worker = new SharedWorker(&apos;shared-worker.js&apos;); worker.port.onmessage = function(e) { msg = &apos;Someone just said &quot;&apos; + e.data.message + &apos;&quot;. That is message number &apos; + e.data.counter; console.log(msg); }; worker.port.postMessage(&apos;hello shared worker!&apos;); shared-worker.js: var counter = 0; var connections = []; onconnect = function(eConn) { var port = eConn.ports[0]; // 此连接的特有port //当有消息的时候通知所有的连接 port.onmessage = function(eMsg) { counter++; for (var i=0; i &lt; connections.length; i++) { connections[i].postMessage({ message: eMsg.data, counter: counter }); } } port.start(); connections.push(port); 用两个窗口打开这个页面，第一个显示：Someone just said “Hello shared worker!” This is message number 1，第二个也收到一样的信息，但是后面是message number 2。 【安全性和错误检查】出于安全性的考虑，web worker必须遵守同源策略。同时，它的全局对象是worker对象本身，this和self引用的都是worker对象。只能访问： navigator 对象（仅限appName, appVersion, platform, userAgent） location 对象（只读） XMLHttpRequest setTimeout(), setInterval(), clearTimeout()和clearInterval()方法 不能访问： DOM(不是线程安全的) window 对象 document 对象 parent 对象 worker内部出现错误时，可以用worker.onerror侦听到，error的事件有三个属性： filename: 发生错误的文件名 lineno: 代码行号 message: 完整的错误信息 如： worker.onerror = function(e) { console.log(e.filename+&quot;ERROR on line&quot;+e.lineno+&quot;,msg:&quot;+e.message); } 【web worker的其他尝试】对于比较消耗时间的操作，我们可看到web worker能够发挥它的作用。比如：大量数据排序，精确到像素的canvas计算等。而我们又知道，jsonp加载数据时，动态创建script标签，加载和执行这些过程都是阻塞式的，而web worker正好可以异步加载，这会是更快的方式吗？带着这个疑问我做了下面的试验，分别用jsonp和worker的方式去加载文件，计算数据返回时延： function tryJsonp(){ var d = (new Date()).valueOf(); var jsonp=document.createElement(&quot;script&quot;); jsonp.type=&quot;text/javascript&quot;; jsonp.src=&quot;worker.js?_=&quot;+d; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(jsonp); jsonp.onload = jsonp.onreadystatechange = function(){ if(!this.readyState||this.readyState==&apos;loaded&apos;||this.readyState==&apos;complete&apos;){ console.log(&apos;jsonp: &apos;+ ((new Date()).valueOf() - d)); } } } function tryWorker(){ var d = (new Date()).valueOf(); var worker = new Worker(&quot;worker.js&quot;); worker.postMessage({&apos;cmd&apos;: &apos;start&apos;, &apos;msg&apos;: &apos;start&apos;}); worker.onmessage = function (event) { console.log(&apos;web worker: &apos;+ ((new Date()).valueOf() - d)); }; } 第一次加载是一份1k大小的文件，每个方法重复5次，返回结果为:第二次加载1800k大小的文件，返回结果为：可以看到对于较小的数据，jsonp还是比web worker要快，这可能是实例化worker对象时带来的影响；而数据偏大时，web worker的加载将会更优，而且它可以异步加载。 THE END. 本文转自Litten]]></content>
      <tags>
        <tag>web</tag>
        <tag>html5</tag>
      </tags>
  </entry>
</search>
